# 2장 기본 개념

## 문법: 스크립트 방식의 파이프라인과 서술적 파이프라인

젠킨스 파이프라인은 **스크립트 방식의 파이프라인**과 **서술적 파이프라인** 두 가지 방식을 사용해 관리할 수 있다.

### 스크립트 방식의 파이프라인

* 젠킨스에서 pipelines-as-cde가 수행되는 초기의 방법
* 명력적인 스타일의 로직에 기반하고 파이프라인 스크립트의 흐름을 따른다.
* 그루비 언어와 명령어에 밀접하게 연관돼 있고, 특히 에러 확인과 예외 처리 부분에서 의존성이 강하다.

```groovy
// 스크립트 방식의 파이프라인
node('worker_node1') {
    stage('Source') { // 코드 가져오기
        // 깃 저장소에서 코드 가져오기
        git 'git@diyvb2:/home/git/repositories/workshop.git'
    }
    stage('Compile') { // 컴파일과 단위 테스트 수행
       // 컴파일과 단위 테스트를 위해 그레이들 실행
       sh "gradle clean compileJava test"
    }
}
```

### 서술적 파이프라인

* 서술적 문법은 젠킨스의 새로운 선택지이다.
* 주요 영역에서 필요한 상태와 결과를 나타내는 구역이 잘 나뉘어져 있으며 로직 자체에 대한 집중은 적다.

```groovy
// 서술적 파이프라인
pipeline {
    agent {label 'worker_node1'}
    stages {
        stage('Source') { // 코드 가져오기
            steps {
                // 깃 저장소에서 코드 가져오기
                git 'git@diyvb2:/home/git/repositories/workshop.git'
            }
        }
        stage('Compile') { // 컴파일과 단위 테스트 수행
            steps {
                // 컴파일과 단위 테스트를 위해 그레이들 실행
                sh "gradle clean compileJava test"
            }
        }
    }
}
```

### 스크립트 방식의 파이프라인과 서술적 파이프라인 중 선택

* **서술적 방식**은 새로운 파이프라인 사용자가 배우고 유지하기에 더 쉽고 기존 젠킨스처럼 바로 사용 가능한 기능을 원하는 경우에 유용하지만 제공되는 구조에서 벗어나는 일을 할 수 있는 유연성이 적다.

* **스크립트 방식**은 더 유연해 숙련된 사용자가 이 구조를 이용해 더 많은 일을 할 수 있다.
* 하지만 결국 두 방식 모두 대부분의 경루를 처리할 수 있다.

#### 스크립트 파이프라인 장단점

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 대체로 더 적은 섹션과 설명이 필요하다.                       | 대체로 더 많은 프로그래밍이 필요하다.                        |
| 더 많은 절차형 코드를 사용 가능하다.                         | 문법 검사가 그루비 언어와 환경에 국한된다.                   |
| 프로그램을 작성하는 것과 유사하다.                           | 전통적 젠킨스 모델과 연관이 적다.                            |
| 전통적인 pipeline-as-code 모델로서 더 익숙하고 하위 호환성이 좋다. | 서술적 파이프라인에서 같은 내용의 구현이 가능하다고 가정하면, 상대적으로 더 복잡하다. |
| 필요시 맞춤화된 동작을 수행하기 쉽다.                        |                                                              |
| 더 복잡한 흐름과 파이프라인을 설계할 수 있다.                |                                                              |

#### 서술적 파이프라인 장단점

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 더 구조화돼 전통적 젠킨스 웹 폼과 유사하다.                  | 반복되는 로직에 대한 지원이 적다(프로그램적 요소가 적다).    |
| 필요한 것을 선언하는 것이 유연해 대체로 가독성이 좋다.       | 아직 발전 중이다(기존 젠킨스에서 지원됐던 기능이 지원되지 않을 수 있다). |
| 블루 오션 화면의 인터페이스를 이용해 생성가능하다.           | 유연성이 적은 구조다(맞춤화된 파이프라인 코드 작성이 더 어렵다). |
| 알림과 같이 기존 젠킨스 개념에 대응될 수 있는 섹션이 존재한다. | 현재 복잡한 파이프라인이나 워크 플로우에 잘 적용되지 않는다. |
| 문법 확인 및 에러 확인이 쉽다.                               |                                                              |
| 파이프라인 사이의 일관성이 높다.                             |                                                              |



## 시스템: 마스터, 노드, 에이전트, 엑시큐터

### 마스터

* 젠킨스 인스턴스 제어에 중심이 되는 역할을 한다.
* 마스터에는 젠킨스의 모든 설정과 옵션, 잡에 대해 완전한 권한이 있으며, 다른 시스템에 정의되지 않았다면 잡을 실행하는 기본 장소가 된다.
* 마스터는 무거운 작업을 수행하는 데는 적합하지 않다. 만약 무거운 작업이 필요한 잡이 있다면 마스터가 아닌 다른 시스템에서 수행해야 한다. 그 이유는 마스터에서 수행되는 잡에는 모든 데이터, 환경 설정, 작업에 대해 마스터와 같은 접근 권한이 있어 보안에 심각한 위협이 될 수 있기 때문이며, 마스터가 끊김없이 작업을 관리해야 하므로 과부하로 인해 중단되는 일이 발생하면 안 되기 때문이다.

### 노드

* 젠킨스 잡을 실행할 수 있는 시스템을 의미한다. 여기에는 마스터 혹은 에이전트가 포함되며, 때로는 이 둘을 지칭하는 용어로 사용되기도 한다.

### 에이전트

* 마스터가 아닌 시스템을 의미하며, 마스터에 의해 관리되고 필요해 의해 할당되어 각 잡의 수행을 담당한다.

### 엑시큐터

* 엑시큐터는 노드나 에이전트에서 잡을 실행시키는 장소다.
* 노드는 엑시큐터를 여러개를 갖고 있을 수도 있고, 하나도 갖고 있지 않을 수도 있으며, 엑시큐터의 개수에 따라 해당 노드에서 동시에 실행될 수 있는 잡의 개수가 정의된다.
* 마스터가 잡을 특정 노드에 할당했을 때 해당 잡이 즉시 수행되려면 사용 가능한 엑시쿠터가 있어야 한다. 그렇지 않으면 엑시큐터가 사용 가능해질 때까지 기다리게 된다.
* 엑시큐터의 숫자와 다른 변수는 노드를 만들 때 설정 가능하다.



## 구조: 젠킨스 DSL 사용하기

* DSL은 Domain-Specific Language의 약자로, 젠킨스 파이프라인 생성을 위한 프로그래밍 언어다.
* 젠킨스 DSL은 그루비 언어를 이용해 작성한다.
* 아래의 예시에서는 **스크립트 방식의 파이프라인 관점**에서 살펴볼 것이다.

```groovy
node ('worker1') {
   stage('Source') { // 화면 표시 목적
      // 깃 저장소에서 코드 가져오기
      git 'https://github.com/brentlaster/gradle-greetings.git'
   }
}
```

### 노드

* 노드는 마스터나 에이전트를 위한 용어이며, 각 노드에는 젠킨스 에이전트가 설치돼 잡을 실행하게 된다. (여기서는 worker1이라는 레이블을 가진 젠킨스 노드가 있다고 가정한다)
* `node(label_name)` 은 젠킨스에게 어떤 노드에서 해당 파이프라인을 실행해야 하는지 알려준다. 레이블 명칭은 이미 정의된 노드나 시스템이어야 하고 젠킨스가 이를 알고 있어야 한다.
* 레이블을 생략할 경우 master가 실행을 위한 기본 노드일 경우, 이 잡을 master에서 수행하며, 그 외의 경우 젠킨스가 노드 중 가용한 첫 번째 엑시큐터를 이용해 잡을 수행하게 한다.

> 💡하나의 노드에 여러 개의 레이블 활용하기
>
> 파이프라인에서 잡을 수행할 레이블을 지정하는 곳에서 or를 위해서는 `||` 를, and를 위해서는 `&&` 를 사용하면 된다.  
>
> ```groovy
> // 예시) 미국 동부에 위치한 모든 리눅스 노드에 다음 잡을 수행
> node("linux && east") {}
> ```

* 노드는 매핑과 연동되어 코드 블록을 어디에서 실행할지 결정할 수 있다.

  ```groovy
  parallel (
    win: { node('wind64'){
      ...
  	  }},
    win: { node('ubuntu'){
      ...
    	}},
  )
  ```

### 스테이지

* 노드 정의 부분 안에 존재하는 stage 클로저는 각각의 설정, DSL 명령어, 로직을 그룹으로 묶을 수 있게 해준다.
* 스테이지는 이름이 꼭 필요하며, 하나의 스테이지에 파이프라인 로직을 얼마나 포함하게 할지는 개발자에게 달려있다. 하지만 권장되는 방식은 각각의 스테이지를 전통적인 파이프라인 하나가 담당하는 크기로 나누는 것이다.
  * 예를 들어, 소스 코드를 내려받는 작업이나 이를 컴파일하는 것, 단위 테스트를 실행하는 것, 통합 테스트를 실행하는 것 등이 될 수 있다.

### 스텝

* 스테이지 안에는 실제 젠킨스 DSL 명령어가 들어가며 이를 스텝이라고 한다. 스텝은 DSL에서 가장 최소 기능 단위가 된다.

* 젠킨스 DSL에서 스텝은 맵 형태의 매개 변수를 사용한다. 

  * git 스텝을 정의하는 예시

    ```groovy
    // 괄호를 생략한 버전 > [매개 변수 명: 값, 매개 변수 명: 값] 의 형태
    git branch: 'test',
        url: 'https://github.com/brentlaster/gradle-greetings.git'
    
    // 괄호를 생략하지 않은 버전
    git ([branch: 'test',
        url: 'https://github.com/brentlaster/gradle-greetings.git'])
    
    // 하나의 매개 변수만 존재하는 경우 키를 생략할 수 있다.
    git 'https://github.com/brentlaster/gradle-greetings.git'
    ```

  * bat 스텝을 정의하는 예시 (bat 스텝은 윈도우에서 배치나 셸 작업을 위해 사용된다)
  
    ```groovy
    // bat 스텝의 기본 매개 변수는 script 객체다.
    bat([script: 'echo hi'])
    
    // 하나의 매개 변수만 존재하는 경우 키를 생략할 수 있다.
    bat 'echo hi'
    ```
  
    

## 지원되는 환경: 파이프라인 스크립트 개발

### 파이프라인 프로젝트 시작

![image-20231210155243931](./image-20231210155243931.png)

![image-20231210155510595](./image-20231210155510595.png)

![image-20231210155745556](./image-20231210155745556.png)

### 스니펫 생성기 사용하기

![image-20231210155915041](./image-20231210155915041.png)

![image-20231210160433022](./image-20231210160433022.png)

### 파이프라인 실행

```groovy
// 파이프라인 스크립트
node {
   stage('Source') {
      // 깃 저장소에서 코드 가져오기
      git changelog: false, poll: false, url: 'https://github.com/brentlaster/gradle-greetings.git'
   }
   stage('Build') {
       // 할일: 프로젝트에 연관된 그레이들 빌드 실행
       sh 'echo gradle build will go here'
   }
}
```

![image-20231210163608250](./image-20231210163608250.png)

### 리플레이

* 리플레이는 실행 이후 코드를 수정할 수 있게 하여, 변경 사항을 적용시켜 다시 실행할 수 있게 한다. 작업이 실패해 사용자가 코드를 변경하지 않고 간단한 변경을 적용해 다시 실행해보고 싶은 경우 혹은 프로토타입을 만들 경우 리플레이를 사용할 수 있다.
* 리플레이를 사용하면 새로운 빌드 결과는 보존되지만, 원래 코드는 변경되지 않고 유지된다.

![image-20231210164543382](./image-20231210164543382.png)

![image-20231210164703045](./image-20231210164703045.png)
