# 운영체제

## 1. 운영체제 개요

### 운영체제는 왜 필요할까?

컴퓨터는 운영체제가 없어도 동작하는데, 운영체제가 있으면 처음 설계한 대로만 동작하기 때문에 새로운 기능을 추가할 수 없다. 따라서 기본적인 기능 외에도 추가적인 기능을 추가하려면 운영체제가 필요하다.

### 운영체제가 하는 일

1. 프로세스 관리
2. 메모리 관리
3. 입출력 관리
4. 파일 시스템 관리



## 2. 운영체제 역사

### 1940년대

* 미사일 탄도계산을 위해 에니악이 나왔으며, 세계에서 가장 큰 스케일의 전자디지털 계산기였다.
* 에니악은 특정 명령에 맞는 스위치와 배선을 연결해서 프로그래밍을 했다. 이렇게 큰 기계에 많은 스위치와 배선을 이용하기 때문에 인력도 많이 필요하고 시간도 오래 걸렸다.
* 입출력을 위해서 IBM 펀치 카드를 이용했는데, 입출력 속도가 굉장히 느리고 입출력 작업 도중에는 계산을 할 수도 없었다.
* 진공관을 사용했고 공냉식으로 열을 식혔지만 작업 도중에 진공관이 터지면 교체해야 했다.

### 1950년대 초반

* 진공관과 전선으로 만들어진 논리 회로를 아주 작은 크기로 만든 직접 회로(IC)가 개발되었다. 이로써 현대적인 컴퓨터의 모습을 갖추게 되었다. 이때는 CPU와 메모리는 있었지만, 키보드와 모니터는 없었다.
* 펀치 카드에 프로그래머가 카드에 구멍을 뚫어 프로그래밍을 하면 컴퓨터가 카드를 읽어 계산을 하고 결과는 라인 프린터로 출력이 되었다. 기존에 사용했던 스위치와 배선 작업을 하는 것보다 훨씬 편해졌다.

### 1950년대 중후반

* 이전까지만 하더라도 프로그래머가 펀치 카드를 이용해 프로그램을 작성하면 오퍼레이터가 직접 컴퓨터에 카드를 넣고 결과가 나오면 다시 프로그래머에게 전달해 줬다. 하지만 이렇게 하는 방식은 컴퓨터의 처리 속도보다 오퍼레이터가 카드를 넣고 전달하는 과정이 상대적으로 느리게 느껴졌다. 즉, 오퍼레이터의 오버헤드가 너무 컸다.
* 프로그래머가 펀치 카드를 가져오면 여러 개를 한 번에 컴퓨터에 전달해주고 컴퓨터는 여러 개의 프로그램을 순서대로 실행해서 결과도 한번에 확인할 수 있도록 개발했는데, 이를 "싱글 스트림 배치시스템"이라고 부른다.
* CPU의 사용량을 더 높이기 위한 노력을 했다. 당시에는 입출력 작업을 하는 동안에는 CPU를 사용할 수 없었는데, 입출력을 담당하는 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산을 할 수 있도록 만들었다. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 다시 처리하는 식으로 발전되었다.
* 여기서 한 가지 문제점은 CPU와 입출력을 분리했는데, 입출력에도 CPU를 기다려야 하는 작업이 있다. 예를 들면 어떤 작업에서 입력을 받고 그 입력을 처리하는 작업일 때 입력이 전부 완료되어야만 처리를 할 수 있기 때문에 어쩔 수 없이 기다리게 된다. 출력 같은 경우 CPU가 종속적이지 않기 때문에 기다리지 않는다. 이 경우 출력은 I/O 디바이스 컨트롤러를 이용해서 CPU와 분리가 가능하지만 입력인 경우에는 어쩔 수 없이 기다려야 하기 때문에 CPU의 사용률이 떨어진다. "싱글 스트림 배치시스템"은 이러한 한계가 존재한다.

### 1960년대

* 프로그램을 순서대로 하나씩 실행하는 것이 아니라 메모리에 여러 프로그램을 올려 놓고 예를 들어 각 프로그램에 0.1초씩 돌아가면서 실행을 하게 했다. 이렇게 하면 매우 빠르게 번갈아 가면서 실행하기 때문에 사용자에게는 전부 동시에 실행되는 것처럼 보인다. 이런 시스템을 "시분할 시스템"이라고 하며 이것을 통해 싱글 스트림 배치시스템의 한계를 극복했다.
* 프로그램을 동시에 여러 개 실행할 수 있으니 여러 사용자가 한 번에 사용 가능하게 되었다. 컴퓨터는 비싸기 때문에 하나의 컴퓨터를 두고 터미널이라는 단말기를 통해 여러 사용자들이 여러 터미널로 하나의 컴퓨터에 접근해서 사용했다. 사용자는 각자 프로그램을 실행할 수 있었기 때문에 컴퓨터를 혼자 쓰고 있는 듯한 효과도 가지게 되었다. 사용자는 컴퓨터를 혼자 쓰는 것 같아서 컴퓨터에 개인이 필요한 문서와 같은 개인정보를 저장하기 시작했고 이 때문에 "파일 시스템"이 등장했다.
* AT&T 벨 연구소에서 C언어로 유닉스 운영체제를 개발했는데 이 운영체제가 프로그램을 동시에 여러 개 실행시키는 "멀티 프로그래밍"과 여러 사용자를 지원하는 "다중 사용자"와 "파일 시스템"을 구현한 운영체제였다.
* 여러 프로그래밍을 동시에 실행시키려니 생각지도 못한 문제들이 발생했는데, 첫 번째로는 메모리에 여러 프로그램이 올라와서 작업을 실행하기 때문에 메모리 침범 이슈가 생겼다. 또 다른 문제는 기존에는 프로그램을 작성할 때 메모리에는 프로그램이 하나가 있기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍을 했는데 이제는 여러 개가 올라가니 자기가 어느 메모리 위치에서 실행되는지 몰랐다. 그래서 하드웨어적으로 "베이스 레지스터"라는 것을 추가해서 프로그램의 시작 주소를 저장하고 모든 프로그램은 0번지에서 실행한다고 가정하게 된다.

### 1970년대 이후

* 1970년대는 개인용 컴퓨터의 시대가 시작되었다. 이전에는 하드웨어의 가격이 굉장히 고가여서 상업용으로만 주로 이용되었지만 저렴해진 컴퓨터의 가격으로 개인이 소유하기 쉬워졌다. 이때는 애플의 매킨토시와 마이크로소프트의 MS-DOS가 많이 사용되었다. 당시 매킨토시는 GUI를 도입해서 굉장한 인기를 얻었다.



## 3. 운영체제 구조

### 커널

* 프로세스와 메모리 저장장치를 관리하는 핵심적인 기능을 담당한다.
* 사용자는 운영체제의 커널에 직접적으로 접근할 수 없고 인터페이스를 이용해서 접근 가능하다.

### 인터페이스

* 인터페이스의 종류에는 CLI(Command Line Interface)와 GUI(Graphic User Interface)가 있다.
* CLI와 GUI는 텍스트냐 그림이냐의 차이일 뿐 커널에 접근하기 위한 목적은 같다.

### 시스템 콜

* **애플리케이션**은 시스템 콜을 이용해서 커널에 접근할 수 있다.
* 또한 시스템 콜은 **사용자**로부터 자신을 보호하기 위해서도 사용된다. 예를 들면, 사용자가 하드디스크에 직접적인 접근을 막는 것이다.
* **하드웨어**가 커널에 접근하기 위한 인터페이스로는 드라이버를 사용한다. 드라이버는 하드웨어를 만드는 제조사에서 만들어 제공하는 것이 일반적이다.



## 4. 컴퓨터 하드웨어와 구조

### 폰노이만 구조

* 오늘날의 대부분의 컴퓨터 구조는 프로그램 내장 방식의 폰노이만 구조를 하고 있다.
* 애니악을 이용할 때는 하드웨어로 프로그램을 만들었기 때문에 프로그램이 바뀔 때마다 스위치와 배선을 조정해야 했다
* 이를 해결하기 위해 CPU와 메모리를 두고 이들 사이에는 버스로 연결한다. 버슨느 데이터를 전달하는 통로이다
* 프로그램은 메모리에 올려서 실행시키는데 프로그램을 메모리에 내장했다고 해서 프로그램 내장방식이라고 한다.

### 오늘날 컴퓨터 하드웨어

* 가장 기본이 되는 것은 메인보드다. 메인보드는 다른 하드웨어를 연결하는 장치다. 장치간에 데이터를 전달하는 것은 메인보드의 버시가 담당한다.
* 폰노이만 구조이기 때문에 CPU와 메모리는 필수이므로 메인보드에 꽃아준다.
* 하드디스크 연결 단자에는 하드디스크를 꽃아준다.
* 그래픽 카드 연결 단자에는 그래픽 카드를 꽃아준다.
* 출력 단자에 모니터 선을 꽃으면 모니터가 작동한다.
* USB 단자에 마우스와 키보드를 연결한다.
* 사운드 단자에 스피커를 연결한다.

### CPU 구조

* CPU는  Central Processing Unit이라고 하며 중앙처리장치라고 부른다.
* CPU를 구성하는 장치는 3가지로 나뉜다.
* 첫 번째는 산술 논리 연상장치(Arithmetic and Logical Unit, ALU)이며 CPU에서 실제로 데이터의 연산을 담당하는 장치다.
* 두 번째는 제어장치(Control UNIT)이며 모든 장치들의 동작을 지시하고 제어하는 장치다.
* 세 번째는 레지스터이며 CPU 내에서 계산을 위해 임시로 보관하는 장치다.

### 메모리 종류

* 메모리는 크게 RAM(Random Access Memory)와 ROM(Read Only Memory)로 구별할 수 있다.
* RAM은 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다. RAM은 전력이 끊기면 데이터를 읽어버리기 때문에 메인 메모리로 사용된다.
* ROM은 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한 번 쓰면 데이터 수정이 불가능한다. 그래서 ROM은 컴퓨터 부팅과 관련된 BIOS를 저장하는데 주로 쓰인다.



## 5. 컴퓨터의 부팅 과정

* 컴퓨터의 전원을 누르면 ROM에 저장된 BIOS가 실행된다.
* BIOS는 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 있는지 확인한다.
* 만약 주요 장치에 이상이 있다면 오류음을 내면서 부팅이 이뤄지지 않고 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트 로더를 메모리에 가져와서 실행한다.
* 만약 윈도우즈 운영체제와 리눅스 운영체제가 둘 다 설치되어 있다면 어떤 운영체제를 실행할지 선택하는 화면이 나온다.
* 운영체제를 선택했거나 운영체제가 하나면 바로 운영체제를 메모리로 불러오고 모니터에 바탕화면이 나온다.
* 이제부터 실행되는 모든 응용 프로그램은 메모리에 올라와서 운영체제가 관리한다.



## 6. 인터럽트

* CPU는 입출력 작업(마우스, 키보드, 프린터, 하드디스크 등)이 들어오면 입출력 관리자에게 명령을 내린다.
* CPU 관점에서는 입출력 작업이 언제 완료될지 모르기 때문에 주기적으로 계속 확인해야 한다. 이러한 방식을 폴링(polling) 방식이라고 한다.
* 폴링 방식의 단점은 주기적으로 CPU가 확인해줘야 하니 성능이 좋지 않다는 것이다.
* 인터럽트는 폴링 방식의 단점을 해결한 방식이다.
* CPU가 입출력 관리자에게 입출력 명령을 내리고 CPU는 다른 작업을 계속한다. 입출력 관리자는 입출력이 완료됐을 때 CPU에게 신호를 주고 CPU는 그 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료한다.
* 인터럽트 서비스 루틴은 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수다.
* 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있다.
* 인터럽트는 하드웨어 방식과 소프트웨어 방식 두 가지가 있다.
* 하드웨어 방식은 입출력 등과 같은 인터럽트가 있고 소프트웨어 방식은 사용자 프로그램에서 발생한 인터럽트가 있다. 예를 들면, 유효하지 않은 메모리에 접근하거나 0으로 나누는 명령어 등이 있다.

