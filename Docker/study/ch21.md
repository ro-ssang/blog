# 21장 메시지 큐를 이용한 비동기 통신

## 비동기 메시징이란?

### 동기적 통신이란?

클라이언트가 서버에 접속하고, 요청을 보내고, 서버의 응답을 기다린 다음 접속을 종료하는 과정이 순차저으로 이뤄지는 것을 말한다. 예를들어, HTTP 연결에 기반하는 REST API, SOAP 웹 서비스, gRPC 등이 있다.

### 비동기 통신이란?

클라이언트가 서버에 요청할 것이 생기면, 서버에 직접 요청을 보내는 대신 큐에 요청을 보낸다. 서버는 큐를 주시하다가 메시지를 수신하고 처리한다. 처리가 끝나면 서버는 응답 메시지를 큐로 보낸다. 클라이언트가 응답을 필요로 하는 상태라면 큐를 주시하며 서버가 보낸 메시지를 수신한다. 즉, 비동기 통신을 적용하면 클라이언트와 서버 사이에 큐라는 계층이 끼어든다.

### 도커를 이용한 메시징 아키텍쳐 구성하기

통합 아키텍처를 설계할 때 메시징은 아주 매력적인 수단이지만, 큐를 제공하는 기술의 신뢰성이 매우 뛰어나야하고, 이러한 큐 기술의 사용료가 너무 비싸기 때문에 테스트 환경까지 동일하게 도입하기 없으므로 운영 환경과 테스트 환경의 괴리가 생긴다.

하지만 도커를 사용하면 엔터프라이즈급 안정성을 갖춘 오픈 소스 큐 시스템을 도입해 이러한 문제를 해결할 수 있다. 즉, 경량 컨테이너에서 메시지 큐를 실행하면 애플리케이션마다 별도의 전용 메시지 큐를 둘 수 있고, 모든 환경에서 동일하게 도입할 수 있다.

### 레디스를 이용한 비동기 메시지 큐 구성하기

```sh
# 도커 네트워크 생성하기
docker network create ch21

# 레디스 클라이언트를 백그라운드로 실행해 메시지를 전달한다 (5초에 한 번씩 'ping' 메세지를 50번 반복적으로 전송한다)
docker run -d --name publisher --network ch21 diamol/redis-cli -r 50 -i 5 PUBLISH channel21 ping

# 메시지가 보내지는지 로그를 통해 확인한다
docker logs publisher

# 대화식 컨테이너를 실행해 채널을 구독하면 5초마다 한 번씩 메시지를 전달받는다
docker run -it --network ch21 --name subscriber diamol/redis-cli SUBSCRIBE channel21
```

메시지 큐 환경에서 모든 컴포넌트는 메시지 큐의 클라이언트가 된다. 다만 메시지를 보내는 컴포넌트는 **퍼블리셔**(publisher)가 되고, 메시지를 받는 컴포넌트는 **서브스크라이버**(subscriber)가 된다. 다양한 시스템이 메시지 큐를 이용할 수 있으므로 **채널**(channel)을 나눠 메시지를 구분한다.

이렇게 메시지 큐를 이용하면 퍼블리셔는 서스크라이버가 큐를 주시하기 전부터 메시지를 보낼 수 있으며, 서브스크라이버는 퍼블리셔가 하나도 없더라도 큐를 주시할 수 있다. 메시지 큐를 다루는 컴포넌트는 같은 큐에서 메시지를 보내거나 받는 다른 컴포넌트의 존재를 알 수 없다.

이렇게 큐를 이용해 메시지 전달자와 수신자의 결합을 느슨하게 하는 방법으로 애플리케이션의 성능과 확장성을 개선할 수 있다.



## 클라우드 네이티브 메시지 큐 사용하기

메시지 큐를 이용하면 많은 수의 사용자를 감당할 수 있다. 예를들어, 많은 수의 사용자를 감당할 수 있도록 수백 개의 웹 컨테이너를 실행해야 한다면, 금세 데이터베이스 서버의 최대 커넥션 수를 초과하고 애플리케이션이 오류를 일으킬 것이다.

이런 상황에 메시지 큐를 도입하면 성능과 확장성을 함께 개선할 수 있는데, 만약 to-do 애플리케이션에서 웹 애플리케이션이 데이터를 큐에 메시지로 보낸다면, 큐는 데이터베이스 서버의 커넥션 수보다 훨씬 많은 수의 퍼블리셔를 처리할 수 있고 필요한 접속의 지속 시간도 훨씬 짧으므로 많은 사용자가 몰리더라도 여간해서는 처리 한계에 도달하지 않는다.

### NATS를 이용한 비동기 메시지 큐 구성하기

NATS는 CNCF에서 관리하는 프로젝트로, 높은 완성도와 신뢰도를 바탕으로 널리 쓰이고 있다. NATS는 메시지를 메모리에 저장하므로 속도가 매우 빠르고 컨테이너끼리의 통신에 적합하다.

```sh
# 실습 디렉터리로 이동
cd ch21/exercises/todo-list

# 메시지 큐 컨테이너 실행
docker-compose up -d message-queue

# 로그 확인하기
docker container logs todo-list_message-queue_1

# 현재 메시지 큐의 클라이언트 수 확인하기
curl http://localhost:8222/connz
```

NATS에는 채널 개념이 없다. 그 대신 모든 메시지에는 서브젝트(subject)가 부여된다. 이 서브젝트를 통해 메시지의 유형을 구분하며, 서브젝트에 원하는 명명 규칙을 적용할 수 있다.

```sh
# 웹 컨테이너, 데이터베이스 컨테이너 실행
docker-compose up -d todo-web todo-db

# 웹 브라우저에서 http://localhost:8080에 접속해 새 할 일을 추가한다
```

메시지 큐 시스템은 메시지가 큐에 전달됐는데 이 큐를 구독하는 서스크라이버가 없는 상황이 발생하면, 관리자가 대신 처리할 수 있도록 데드레터 큐(dead-letter queue)에 이 메시지를 모아 두거나 해당 큐에 서브스크라이버가 생길 때까지 메시지를 저장해 두는 방법을 사용하기도 한다. 레디스와 NATS는 모두 메시지를 수신할 서스크라이버가 없다면 해당 메시지를 그대로 버리는 방식을 취한다.

```sh
# 'events.todo.newitem' 서브젝트의 메시지를 수신하는 서스크라이버 실행
docker container run -d --name todo-sub --network todo-list_app-net diamol/nats-sub events.todo.newitem

# 서브스크라이버의 컨테이너 로그 확인
docker container logs todo-sub

# 웹 브라우저에서 http://localhost:8080에 접근해 새로운 할 일 추가

# 새 할 일 이벤트 메시지가 제대로 발행되는지 확인
docker container logs todo-sub
```

지금까지 to-do 애플리케이션에는 발행된 메시지를 받아 처리할 컴포넌트가 없다. 비동기 메시징을 적용하려면 메시지 큐, 이벤트 발생 시 메시지를 발행할 퍼블리셔, 메시지를 수신해 이벤트를 처리할 서브스크라이버까지 최소 세 가지의 구성 요소가 필요한데, to-do 애플리케이션에는 이 중 마지막 요소인 서브스크라이버가 빠져 있다.

## 메시지 수신 및 처리

큐를 구독하는 컴포넌트를 메시지 핸들러(message handler)라고 한다. 대게 메시지의 종류마다 이를 처리하는 메시지 핸들러가 하나씩 필요하다. to-do 애플리케이션에는 새 할 일 이벤트 메시지를 처리해 데이터를 데이터베이스에 추가하는 역할을 해 줄 메시지 핸들러가 필요하다.

```sh
# 메시지 핸들러 컨테이너 시작
docker-compose up -d save-handler

# 컨테이너 로그 확인
docker logs todo-list_save-handler_1

# 웹 브라우저에서 http://localhost:8080에 접근해 새로운 할 일 추가

# 이벤트가 잘 처리되는지 확인
docker logs todo-list_save-handler_1
```

이렇게 메시지 핸들러를 컴포넌트를 추가하면 애플리케이션이 잘 동작한다. 하지만 새 할일을 추가하면 목록에 새로 추가된 할 일이 나타나기는 하지만, 약간의 시차가 있다.

비동기 메시징에서 발생하는 이러한 부수 효과를 결과적 일관성(eventual consistency)이라고 한다. 모든 메시지의 처리가 끝나면 애플리케이션 데이터의 상태가 정확해지는데, 그 이전 시점에는 일관성이 깨질 수 있다.

전체 UI가 비 동기적으로 동작할 수 있도록 이 문제를 해결하는 몇 가지 방법이 있는데, 웹 애플리케이션이 '모든 메시지의 처리가 끝나고 할 일 목록이 갱싱됐음'을 의미하는 이벤트를 기다렸다가 그에 맞춰 화면을 리프레시하면 된다. 이러한 푸시 모델(push model)은 지금 사용된 폴링 모델(polling model)에 훨씬 효율적이다.



## 메시지 핸들러로 기능 추가하기

이것으로 to-do 애플리케이션의 아키텍처를 이벤트 지향 아키텍처(event-driven architecture)로 변경했다. 이벤트 지향 아키텍처는 애플리케이션이 모든 일을 즉각 동기적으로 처리하는 대신 이벤트를 통해 다른 구성 요소에 자신의 현재 상태를 알리는 방식을 말하며, 이벤트를 발행하는 로직을 변경하지 않고도 이벤트 처리 로직을 바꿀 수 있으므로 애플리케이션의 구성 요소 간 결합도를 느슨하게 하는 효과가 있다.

기존 애플리케이션을 변경하지 않고 새 기능을 추가할 수 있는 가장 쉬운 방법은 메시지 핸들러의 그룹을 만들고 모든 메시지를 수신하도록 하되 에벤트 처리를 다르게 하는 것이다. 데이터베이스에 데이터를 저장하는 역할을 하는 기존 메시지 핸들러와 달리, 새로운 메시지 핸들러는 데이터를 일래스틱서치에 젖아해 키바나에서 그 내용을 검색하게 할 수도 있고, 새 할 일을 구글 캘린더에 추가할 수도 있다.

```sh
# 동작 확인 핸들러를 실행한다. 개수는 메시지 저장 핸들러와 동일하다
docker-compose -f docker-compose.yml docker-compose-audit.yml up -d --scale save-handler=3

# 동작 확인 핸들러가 메시지를 수신하는지 확인
docker logs todo-list_audit-handler_1

# 웹 브라우저에서 http://localhost:8080에 접근해 새로운 할 일 추가

# 동작 여부 확인
docker logs todo-list_audit-handler_1
```

이렇게 하면 무중단 배포를 할 수 있다. 기존 컨테이너의 변경은 없고, 새 기능은 새 컨테이너로 구현됐다. 동작 확인 핸들러는 메시지 저장 핸들러와 같은 서브젝트를 구독하므로 모든 메시지를 수신할 수 있다. 메시지 저장 핸들러도 마찬가지다.

이제 사용자가 새 할 일을 추가하면 두 가지 처리가 함께 일어난다. 또한, 이 두 가지 처리는 서로 다른 컨테이너에서 동작한다. 웹 UI가 이들 처리가 끝나기를 기다릴 필요가 없으므로 서로 처리 시간이 달라도 사용자 경험에 영향을 미치지 않는다. 웹 UI는 이벤트를 메시지 큐에 발행하며, 아무리 사용자가 많더라도 이 과정의 지연 시간은 고정된다.

앞서 봤듯 같은 유형의 이벤트를 여러 종류의 서브스크라이버가 구독할 수 있는데, 반대로 여러 퍼블리셔도 같은 유형의 이벤트를 발행할 수 있다. 새 할 일 이벤트는 코드에 이미 고정돼 있으므로 어떤 컴포넌트라도 새 할일 이벤트를 발행할 수 있다.

```sh
# 컴포즈 오버라이드 파이에 정의된 API 컨테이너 실행
docker-compose -f docker-compose.yml -f docker-compose-audit.yml -f docker-compose-api.yml up -d todo-api

# API를 사용해 새 할 일 추가
curl http://localhost:8081/todo -d '{"item":"홍보 비디오 촬영"}' -H 'Content-Type:application/json'

# 로그 확인
docker logs todo-list_audit-handler_1
```



## 비동기 메시징 패턴 이해하기

메시지 큐를 컨테이너로 실행하고 이벤트를 발행하는 애플리케이션을 빠르게 프로토타이핑할 수 있기 때문에 도커를 이용해 비동기 메시징의 진입 장벽을 낮출 수 있다.

메시지 큐에 메시지를 전달하고 수신하는 방법도 몇가지 형태가 더 있다.

### 퍼블리시-서브스크라이브(publish-subscribe, pub-sub) 패턴

서브스크라이버(하나 이상이거나 없을 수도 있다)가 퍼블리시된 메시지를 구독하는 형태다.

### 리퀘스트-리스폰스(request-reponse) 패턴

퍼블리시-서브스크라이브 패턴에서는 퍼블리셔가 메시지를 사용하는 것이 누구이고, 어떻게 처리하며, 언제 처리가 끝나는지를 전혀 알 방법이 없는데, 이를 해결할 수 있는패턴이 리퀘스트-리스폰스 패턴이다. 이 패턴에서는 클라이언트가 메시지 큐에 메시지를 전달하고 응답을 기다린다. 핸들러는 요청 메시지를 처리한 다음 응답 메시지를 메시지 큐에 보내고, 큐는 다시 이 메시지를 클라이언트에 전달한다.

이 패턴은 과부하를 일으키지 않는 핸들러와 클라이언트가 기다리는 동안 다른 작업을 할 수 있다는 비동기 메시징의 장점을 그대로 유지하면서도 일반적인 동기 서비스 호출을 대체할 수 있다.

### 그 외의 패턴

대부분의 메시지 큐 기술은 이들 패턴과 그 변종(이를테면 클라이언트가 요청이 아닌 명령 메시지를 보내고 응답은 기다리지 않는 패턴인 fire-and-forget, 여러 서브스크라이버에 메시지를 보낸 다음 이들로부터 응답을 모아 오는 scatter-gather 등)을 모두 지원한다.

### 레빗MQ(RabbitMQ)

레빗MQ는 복잡한 메시지 라우팅과 메시지를 디스크에 저장하는 퍼시스턴트 메시징을 지원한다. 레빗MQ 역시 레디스나 NATS와 마찬가지로 도커 허브에 공식 이미지가 공개돼 있다.
