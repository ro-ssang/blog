# 3장 도커 이미지 만들기

## 도커 허브에 공유된 이미지 사용하기

```sh
docker image pull diamol/ch03-web-ping
```

* 위의 명령어를 실행하면 먼저 로컬에 이미지 캐시가 있는지 확인하는데 해당 이미지가 존재하지 않으면, 도커 레지스트리인 도커 허브에 이미지를 찾아 이미지를 내려받는다.
* 이미지를 다운받을 때는 단건의 파일을 내려받는 것이 아니라, 여러 건의 파일을 동시에 내려받는데 이들 각각의 파일을 이미지 레이어라고 부른다.
* 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성되어 있으며, 도커는 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다.



## Dockerfile 작성하기

* Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트이며, 일련의 인스트럭션으로 구성돼 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다.

```dockerfile
FROM diamol/node

ENV TARGET="blog.sixeyed.com"
ENV METHOD="HEAD"
ENV INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .

CMD ["node", "/web-ping/app.js"]
```

| 인스트럭션 | 내용                                                         |
| ---------- | ------------------------------------------------------------ |
| `FROM`     | 기반 이미지 설정                                             |
| `ENV`      | 환경 변수 값을 지정, `KEY=VALUE` 형식을 따름                 |
| `WORKDIR`  | 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정 |
| `COPY`     | 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사, `[원본경로] [복사경로]` 형식을 따름 |
| `CMD`      | 컨테이너를 실행했을 때 실행할 명령어를 지정                  |

```sh
docker image build -t web-ping .
```

* 위의 명령어를 실행시키면 이미지를 빌드할 수 있는데, `--tag` 의 인자값은 이미지의 이름이고, 이어지는 인자는 Dockerfile 및 이미지에 포함시킬 파일이 위치한 경로이다. 도커에서는 이 디렉터리를 컨텍스트라고 한다.



## 도커 이미지와 이미지 레이어 이해하기

```sh
docker image history web-ping
```

* 위의 명령어를 실행하면 이미지가 어떻게 빌드됐는지에 대한 간단한 이력을 출력하는데, 출력되는 한 줄마다 한 이미지 레이어에 대한 정보가 출력된다. 여기서 이미지 레이어는 Dokerfile에서 작성한 인스트럭션과 1:1 관계를 갖는다.
* 이미지 레이어란 도커 엔진 캐시에 물리적으로 저장된 파일이며, 도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 즉, 이미지 레이어는 여러 이미지와 컨테이너에서 공유되어 사용할 수 있다. 예를 들어, Node.js 애플리케이션이 실행되는 컨테이너를 여러 개 실행한다면 이들 컨테이너는 모두 Node.js 런타임이 들어 있는 이미지 레이어를 공유한다.
* 또한 공유된 이미지 레이어는 수정할 수 없어야 하는데, 도커는 이미지 레이어를 읽기 전용으로 만들어 두어 이런 문제를 방지한다. 

> 💡 `docker image ls` 명령어를 실행시키면 각 이미지가 디스크 용량을 차지하는 크기를 확인할 수 있는데, 이는 논리적인 크기이며 실제 이미지가 차지하는 디스크 용량을 확인하려면 `docker system df` 명령어를 통해 확인할 수 있다.



## 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화

* Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결되며, 이미지 레이어는 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산된 해시값으로 구분된다.
* 이 해시값은 이미지를 빌드할 때, 캐시된 이미지 레이어의 해시값과 비교해 변경되지 않았으면 이전에 캐시된 이미지 레이어를 재사용한다.
* 또한 이미지 레이어는 Dokerfile에 있는 순서대로 배치되며, 이미지를 빌드할 때 순서 중간에 있는 이미지 레이어가 변경된다면 변경된 레이어보다 위에 오는 레이어는 수정된 것이 없이 없더라도 다시 실행된다.
* 이러한 연유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다.

```dockerfile
# 위에 있는 Dockerfile을 최적화한 결과
FROM diamol/node

CMD ["node", "/web-ping/app.js"]

ENV TARGET="blog.sixeyed.com" \
		METHOD="HEAD" \
		INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .
```



## 이미지 명령어

### 이미지 내려받기

```sh
docker image pull <IMAGE NAME or IMAGE ID>
```

### 이미지 목록 출력

```sh
docker image ls
```

### 이미지 삭제

⚠️ 이미지를 삭제하려면 해당 이미지로 실행된 컨테이너를 모두 삭제해야 한다.

```sh
docker image rm <image name>
```

### 이미지 빌드

```sh
docker image build -t <TAG NAME> <DOCKER FILE PATH>
```

| 옵션                                 | 내용                 |
| ------------------------------------ | -------------------- |
| `--tag <TAG NAME>` , `-t <TAG NAME>` | 생성될 이미지의 이름 |

### 이미지 히스토리 확인하기

```sh
docker image history <IMAGE NAME>
```


### 사용중인 디스크 용량

```sh
docker system df
```

