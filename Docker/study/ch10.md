# 10장 도커 컴포즈를 이용한 여러 환경 구성

## 도커 컴포즈로 여러 개의 애플리케이션 배포하기

도커 컴포즈를 사용해 다음과 같이 똑같은 명령행을 두 번 실행해 애플리케이션을 실행해 보자.

```sh
# to-do 애플리케이션을 실행
docker-compose -f ./todo-list/docker-compose.yml up -d

# to-do 애플리케이션을 하나 더 실행
docker-compose -f ./todo-list/docker-compose.yml up -d
```

첫 번째로 실행한 애플리케이션은 잘 실행되지만, 두 번째로 실행한 애플리케이션은 이미 실행중인 애플리케이션이라고 해서 똑같은 애플리케이션이 두 개 이상 실행되지 않는다. 이렇게 똑같은 명령행으로 두 번 이상 실행할 때 실행되지 않는 이유는 **도커는 레이블 명으로 어떤 도커 리소스(볼륨, 컨테이너 등)가 어떤 애플리케이션의 일부인지를 판단**하는데, 이 레이블명은 기본적으로 컴포즈 파일이 들어있던 디렉터리명을 프로젝트 명으로 간주해 리소스의 이름에 접두사로 붙이고, 컨테이너 이름에는 번호를 접미사로 붙여 정해지기 때문에 두 번째 명령행을 실행했을 때 이미 똑같은 레이블명이 존재하기 때문에 애플리케이션이 실행되지 않는다.

```sh
# 레이블명 예시
# 만약 도커 컴포즈 파일에 정의된 볼륨의 이름이 disk라고 하고, 서비스의 이름이 web이라고 하면 todo-list가 리소스의 접두사가 되어 볼륨은 todo-list_disk로 컨테이너는 todo-list_web_1이라는 레이블명이 정해진다.
docker-compose -f ./todo-list/docker-compose.yml up -d
```

만약 도커를 이용해 단일 호스트 머신에서 도커 컴포즈를 이용하여 똑같은 애플리케이션을 여러 개 실행하고 싶다면 위의 방식으로는 불가능한데, 도커 컴포즈 명령행에서 `-p` 플래그를 이용하여 여러 개의 애플리케이션을 실행할 수 있다.

```sh
# 아래의 레이블명의 접두사는 todo-list가 된다.
docker-compose -f ./todo-list/docker-compose.yml up -d

# 아래의 레이블명의 접두사는 todo-test가 된다.
docker-compose -f ./todo-list/docker-compose.yml -p todo-test up -d
```

이처럼 `-p` 옵션을 이용해 똑같은 도커 컴포즈 파일로 여러 개의 애플리케이션을 실행할 수 있는데, 만약 단일 호스트 머신에서 개발, 테스트, 운영 환경 등 각기 다른 설정(포트, 환경변수 등)으로 애플리케이션을 실행할 수 없다는 한계를 가지고 있다. 하지만 도커 컴포즈 파일을 오버라이드하여 이러한 문제를 해결할 수 있다.



## 도커 컴포즈의 오버라이드 파일

하나의 애플리케이션을 여러 설정으로 실행해야 할 경우 컴포즈 파일을 각 설정 또는 환경마다 하나씩 두는 방법을 쓸 수 있지만 이 방법은 유지 보수 측면에서 바람직하지 않다.

도커 컴포즈 명령행의 `-f` 플래그에는 실행시킬 도커 컴포즈 파일을 명시할 수 있고 `-f` 플래그를 여러번 사용하여 실행할 도커 컴포즈 파일을 나열할 수 있는데, 오른쪽에 명시된 도커 컴포즈 파일은 왼쪽에 도커 컴포즈 파일을 덮어쓰는 방식으로 동작하여 실행된다. 이렇게 도커 컴포즈 파일을 오버라이드 한다면 높은 유지 보수성을 가질 수 있다.

```yaml
# docker-compose.yml - 기본 파일
services:
	todo-web:
		image: diamol/ch06-todo-list
		ports:
			- 80

# docker-compose-v2.yml - 오버라이드 파일
services:
	todo-web:
		image: diamol/ch06-todo-list:v2
```

```sh
# 다음 명령행을 실행하면 todo-web 애플리케이션의 이미지 버전은 docker-compose-v2 파일에 명시된 이미지인 diamol/ch06-todo-list:v2 로 결정된다.
docker-compose -f ./todo-list/docker-compose.yml -f ./todo-list/docker-compose-v2.yml up -d

# 만약 도커 컴포즈를 사용하여 애플리케이션을 종료하려면 애플리케이션을 실행할 때 사용한 모든 파일과 프로젝트 정보를 정확히 지정해 down 부명령어를 사용해야 한다.
docker-compose -f ./todo-list/docker-compose.yml -f ./todo-list/docker-compose-v2.yml down -d
```

이렇게 기본이 되는 도커 컴포즈 파일 외에 각 환경에 맞는 설정을 따로 분리하여 관리한다면 최종 실행될 도커 컴포즈 파일의 최종 형상을 알기 힘든데 도커 컴포즈 부명령어인 `config` 를 사용하면 최종 실행할 도커 컴포즈 파일의 형상을 확인할 수 있다.

```sh
docker-compose -f ./todo-list/docker-compose.yml -f ./todo-list/docker-compose-v2.yml config
```

오버라이드를 활용한 실전 응용 사례는 다음과 같이 구성할 수 있다.

| 파일명                    | 대상                    | 설명                                                         |
| ------------------------- | ----------------------- | ------------------------------------------------------------ |
| `docker-compose.yml`      | 기본 컴포즈 파일        | 웹 및 API 서비스가 정의 됐으나 포트나 도커 네트워크에 대한 정의는 빠져 있다. |
| `docker-compose-dev.yml`  | 개발 환경               | 도커 네트워크 및 서비스의 공개 포트를 정의하고 헬스 체크와 디펜던시 체크를 비활성화 한다. |
| `docker-compose-test.yml` | 테스트 환경             | 도커 네트워크를 정의하고, 헬스 체크를 설정하고, 웹 서비스의 공개 포트를 정의한다. 그러나 API 서비스의 포트는 공개하지 않는다. |
| `docker-compose-uat.yml`  | 사용자 인수 테스트 환경 | 도커 네트워크를 설정하고, 웹 서비스는 80번 표준 포트로 공개하고, 서비스가 오류 발생 시 항상 재시작하도록 설정하고, 헬스 체크를 좀 더 꼼꼼하도록 지정한다. |



## 환경 변수와 비밀값을 이용해 설정 주입하기

여러 개의 애플리케이션을 도커 네트워크를 사용해 분리하고 각 환경 간의 차이를 도커 오버라이드 파일을 통해 기술할 수 있었다. 그러나 환경 간에 애플리케이션 설정을 달리해야 하는 경우도 있다. 대부분의 애플리케이션은 설정을 환경 변수나 설정 팔일로부터 읽어 오는데, 도커 컴포즈도 이들 수단을 충실히 지원한다.

| 필드명        | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| `environment` | 컨테이너 안에서만 사용되는 환경 변수를 추가한다.             |
| `env_file`    | 텍스트 파일의 결로를 값으로 받는데, 이 파일에 정의된 환경 변수가 컨테이너에 적용된다. 텍스트 파일에 변수 이름과 값을 등호(`=`)로 구분해 한 줄에 하나씩 정의하면 같은 환경 변수를 여러 번 정의하지 않아도 환경 변수를 여러 컴포넌트에서 공유해 사용할 수 있다. |
| `secrets`     | `services` 나 `network` 처럼 컴포즈 파일의 최상위 프로퍼티이며, 도커 컴포즈, 도커 스웜, 쿠버네티스에서 모두 지원하는 기능으로써 설정값을 주입하기에 매우 유용한 기능이다. 컴포즈 파일에서 비밀값의 원본 위치와 대상 위치를 모두 지정할 수 있는데, 원본 위치는 컨테이너 런타임이 비밀값의 값을 읽어 오는 곳이고 대상 위치는 컨테이너 안에서 비밀값이 위치할 경로를 의미한다. |

```yaml
# docker-compose.yml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    secrets:
      - source: todo-db-connection
        target: /app/config/secrets.json
```

```yaml
# docker-compose-dev.yml
version: "3.7"

services:
  todo-web:
    ports:
      - 8089:80
    environment:
      - Database:Provider=Sqlite
    env_file:
      - ./config/logging.debug.env

secrets:
  todo-db-connection:
    file: ./config/empty.json
```

또한 **호스트 컴퓨터의 환경 변수값을 컨테이너에 전달하는 방법**도 있는데, 이 방법을 사용하면 컴포즈 파일을 수정하지 않아도 설정값을 변경할 수 있기 때문에 애플리케이션의 이식성이 향상된다.

```yaml
services:
  todo-web:
    ports:
      - "${TODO_WEB_PORT}:80"
    environment:
      - Database:Provider=Postgres
    env_file:
      - ./config/logging.information.env
    networks:
      - app-net
```

도커 컴포즈의 유용한 기능으로써 도커 컴포즈로 애플리케이션을 실행할 때 대상 디렉터리에서 `.env` 파일을 발견하면, 이 파일을 환경 파일로 간주하고 파일의 내용으로부터 환경 변수를 읽어들여 애플리케이션을 실행하기 전에 먼저 적용한다. `.env` 파일에 도커 컴포즈 실행 옵션을 지정할 수 있는데, 도커 컴포즈에 따로 실행 옵션을 붙이지 않으면 `.env` 에 설정한 도커 컴포즈 실행 옵션이 지정된다.

```
# 도커 컴포즈 실행 옵션
COMPOSE_PATH_SEPARATOR=;
COMPOSE_FILE=docker-compose.yml;docker-compose-test.yml
COMPOSE_PROJECT_NAME=todo_ch10
```

### 정리

* `environment` 필드를 사용해 환경 변수를 지정하는 방법은 간단하고 컴포즈 파일의 가독성도 좋다. 그러나 평문 텍스트로 작성되기 때문에 API 키나 데이터베이스 접속 정보 같은 민감한 정보에는 사용하지 않는 편이 좋다.
* 비밀값에 설정값을 지정하는 방법은 모든 컨테이너 런타임에서 적용 가능하고 민감한 정보가 유출될 우려도 없기 때문에 유연성 면에서 가장 뛰어나다. 비밀값의 실제 값은 로컬 파일 시스템에 저장할 수도 있고 도커 스웜이나 쿠버네티스 클러스터에 저장할 수도 있다. 실제 값이 어디에 저장되는 애플리케이션이 실행될 때 컨테이너 속의 특정한 파일로 전달된다.
* 설정값을 파일에 저장한 다음 이 파일의 경로를 `environment-file` 프로퍼티에 지정하는 방법은 서비스 간에 공유하는 설정이 많은 경우에 유용하다. 컴포즈가 로컬에 위치한 파일을 읽어 각 설정값을 지정해 주기 때문에 원격 컴퓨터에서 실행 중인 도커 엔진을 다룰 때도 로컬 컴퓨터의 설정값을 적용할 수 있다.
* 환경 파일 `.env` 는 환경을 막론하고 기본 설정을 지정할 때 유용하다.

