# 13장 도커 스웜 스택으로 분산 애플리케이션 배포하기

## 도커 컴포즈를 사용한 운영 환경

* **운영 환경에서**는 매니저 노드에 접속해 명령행 도구를 사용하여 오케스트레이션을 사용하지 않고, **애플리케이션의 '원하는 상태'를 정의한 YAML 파일을 전달하여 오케스트레이션을 사용**한다. 도커 스웜과 쿠버네티스 모두 이 '원하는 상태' 방식을 취하지만 두 도구가 사용하는 YAML 문법이 서로 다르다.

### 단일 노드에 도커 스웜으로 배포하기

```yaml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
```

```sh
# 컴포즈 파일로 스택을 배포한다
docker stack deploy -c ./todo-list/v1.yml todo

# 스택의 목록에서 새로 생성된 스택을 확인한다
docker stack ls

# 서비스의 목록을 확인해 새로 생성된 서비스를 확인한다
docker service ls
```

* 스웜 모드에서는 애플리케이션을 배포할 때 스택을 만드는데, **스택이란 서비스, 네트워크, 볼륨 등 여러 개의 도커 리소스를 묶어 만든 리소스**를 말한다.

### 여러 노드에 도커 스웜으로 배포하기

```yaml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: "0.50"
          memory: 100M
```

```sh
# 수정된 컴포즈 파일을 스웜에 전달한다
docker stack deploy -c ./todo-list/v2.yml todo

# 웹 서비스의 레플리카 상태를 확인한다
docker service ps todo_todo-web
```

* **스웜에 노드가 두 개 이상이라면 고가용성을 확보**할 수 있다. 고가용성이란 서비스 레플리카를 실행 중인 노드가 고장을 일으켜도 남아 있는 노드에서 대체 레플리카를 실행해 애플리케이션을 복구할 것이라는 의미다.
* **고가용성을 확보하려면 컴포즈 파일에 deploy 프로퍼티을 추가**해야 하는데, 이 프로퍼티는 단일 서버에서 도커 컴포즈로 애플리케이션을 실행해도 해당 프로퍼티가 무시될 뿐 실행이 불가능한 것은 아니다.
* **deploy 프로퍼티에는 레플리카의 개수 뿐만 아니라 한 레플리카의 계산 자원의 사용량을 제한하도록 설정**할 수 있는데, 서비스가 차지할 수 있는 계산 자원에 대한 상한을 설정해 두면 악의적인 레플리카가 해당 노드의 계산 자원을 고갈시키는 것을 방지할 수 있다. 다만 이 상한치를 결정하려면, 애플리케이션이 최대 성능으로 동작할 때 어느 정도의 CPU와 메모리를 필요로 하는지 미리 확인할 필요가 있다.

### 도커 스웜의 스택 명령어

* 클러스터는 일반적으로 많은 수의 애플리케이션을 실행하기 때문에 애플리케이션도 그룹으로 만들어 관리해야 한다. 도커 스웜에서는 스택을 만들어서 애플리케이션을 그룹화하여 관리한다.

```sh
# 스택을 배포
docker stack deploy -c ./todo-list/v1.yml todo

# 스택의 서비스 목록 확인
docker stack services todo

# 각 서비스의 레플리카 목록 확인
docker stack ps todo

# 스택 제거
docker stack rm todo
```



## 컨피그 객체를 이용한 설정값 관리

### 컨피그 객체란?

* 컨피그 객체는 애플리케이션에 전달할 설정값을 정의한 도커 스웜 리소스이다.

### 컨피그 객체 만들기

```sh
# 로컬에 위치한 JSON 파일로 컨피그 객체를 만든다
docker config create todo-list-config ./todo-list/configs/config.json

# 컨피그 객체의 목록을 확인한다
docker config ls

# 컨피그 객체 확인
docker config inspect --pretty todo-list-config
```

* 객체의 이름과 설정값이 담긴 파일 경로를 지정하면 컨피그 객체를 만들 수 있다.
* 컨피그 객체 포맷을 JSON 포맷 뿐만 아니라 XML, 키-값 쌍, 바이너리 파일까지 다양한 데이터 포맷을 담을 수 있다.

### 컨피그 객체를 사용하는 애플리케이션 배포하기

```yaml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    configs:
      - source: todo-list-config
        target: /app/config/config.json

# ...

configs:
  todo-list-config:
    external: true
```

```sh
# 수정된 정의에 따라 애플리케이션 배포
docker stack deploy -c ./todo-list/v3.yml todo

# 스택에 포함된 서비스 목록을 확인한다
docker stack services todo
```

* 이 서비스의 레플리카가 될 컨테이너의 실행과 함께 컨피그 객체의 내용이 컨테이너 파일 시스템의 `/app/config/config.json` 파일로 옮겨진다.
* 컴포즈 파일의 두 번째 부분은 컨피그 객체 자체를 정의한 것인데, `external` 플래그는 해당 리소스가 이미 클러스터에 저장돼 있음을 의미하며 배포 워크플로는 컨피그 객체를 먼저 배포하고 그다음에 애플리케이션을 배포하도록 돼 있다.

### 컨피그 객체를 다룰 때 주의사항

* 클러스터에서 컨피그 객체를 한 번 만들고 나면 내용이 변하지 않아 컨피그 객체는 수정이 불가능하다. 만약 내용을 변경할 필요가 생긴다면 새로운 컨피그 객체를 만들어 스택을 재배포하여야 한다.
* 컨피그 객체는 암호화되지 않으며 클러스터 접근 권한이 있는 사람이라면 누구든 전체 내용을 볼 수 있기 때문에, 컨피그 객체에는 민감한 데이터를 보관해서는 안된다.
* 사용자명과 패스워드가 포홤되는 데이터베이스 접속 문자열, 운영 환경용 API 키, API URL 등이 민감한 정보에 속한다.



## 비밀값을 이용한 대외비 설정 정보 관리하기

### 비밀값이란?

* 비밀값은 클러스터의 관리를 받는 스웜 리소스이며 컨피그 객체와 비슷한 점이 많다. 비밀값이 컨피그 객체와 가장 크게 다른 점은 비밀값은 항상 암호화된 상태로 존재하다가 비밀값을 사용하는 워크플로 중 비밀값이 컨테이너에 전달된 상태에서만 복호화된 비밀값을 볼 수 있다는 것이다.

### 비밀값 만들기

```sh
# 로컬에 위치한 JSON 파일의 내용으로 비밀값을 생성한다
docker secret create todo-list-secret ./todo-list/secrets/secrets.json

# 새로 만든 비밀값의 정보를 확인한다
docker secret inspect --pretty todo-list-secret
```

* 사용 방법만 보면 비밀값을 컨피그 객체와 다를 바가 없지만 차이점이 있다면 리소스의 메타데이터만 나올 뿐 실제 데이터는 출력되지 않는다.

### 비밀값을 사용하는 애플리케이션 배포하기

```yaml
version: "3.7"

services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    configs:
      - source: todo-list-config
        target: /app/config/config.json
    secrets:
      - source: todo-list-secret
        target: /app/config/secrets.json

# ...

secrets:
  todo-list-secret:
    external: true
```

```sh
# 초신 버전의 애플리케이션을 배포한다
docker stack deploy -c /todo-list/v4.yml todo

# 스택에 포함된 레플리카의 정보를 확인한다
docker stack ps todo
```

### 비밀값을 다룰 때 주의사항

* 비밀값도 컨피그 객체와 마찬가지로 수정이 불가능하다. 만약 내용을 변경할 필요가 생긴다면 새로운 비밀값을 만들어 스택을 재배포하여야 한다.



## 스웜에서 볼륨 사용하기

### 클러스터 환경에서의 볼륨 특징

* 클러스터는 여러 개의 노드로 구성되고, 이들 노드는 각각 디스크가 있어서 이 디스크에 로컬 볼륨을 저장한다.
* 만약 어떤 레플리카를 대체하는 새로운 레플리카가 이전 레플리카와 다른 노드에서 실행된다면 새 레플리카는 기존 레플리카가 사용하던 로컬 볼륨에 접근할 수 없다. 따라서 이러한 문제는 서비스가 데이터가 있는 특정 노드에서만 실행되게끔 고정하여 문제를 해결할 수 있다. 다만 레플리카를 여러 개 실행하지 않고 서버 고장도 일어나지 않는 상황이어야 한다.

### 로컬 볼륨 사용하기

```sh
# 노드의 식별자를 찾아 해당 노드에 레이블을 부여한다
docker node update --label-add storage=raid $(docker node ls -q)
```

```yaml
version: "3.7"

services:
  todo-db:
    image: diamol/postgres:11.5
    volumes:
      - todo-db-data:/var/lib/postgresql/data
    deploy:
      placement:
        constraints:
          - node.labels.storage == raid
    networks:
      - app-net

# ...

volumes:
  todo-db-data:
```

```sh
# 노드에 존재하는 모든 볼륨의 식별자 목록을 출력한다
docker volume ls -q

# 스택을 업데이트한다
docker stack deploy -c ./todo-list/v5.yml todo

# 볼륨 목록을 다시 한 번 확인한다
docker volume ls -q
```

* 로컬 볼륨을 적용하려면, 노드에 레이블을 부여하고 컴포즈 파일에서 해당 노드에서만 레플리카를 실행하도록 강제하면 된다.

### 스웜에서 볼륨을 다룰 때 주의사항

* 디스크를 데이터 캐시 정도로 사용한다면 로컬 볼륨으로도 별문제가 없겠지만, 레플리카마다 데이터가 다를 수도 있는 로컬 볼륨은 여로 노드에 걸쳐 상태를 공유해야 하는 애플리케이션에서는 사용할 수 없다.
* 도커는 볼륨 드라이버에 플러그인 시스템을 채용하고 있어 스웜에서 클라우드 스토리지나 데이터센터의 스토리지 장비를 분산 스토리지로 사용하게끔 설정할 수 있다.



## 클러스터는 스택을 어떻게 관리하는가?

### 볼륨

* 스웜도 볼륨을 생성하고 삭제할 수 있다. 서비스 이미지에 볼륨의 정의가 포함된 경우 스택도 기본 볼륨을 생성하지만, 기본 볼륨은 스택을 제거하면 함께 제거된다. 스택 정의에 이름이 붙은 볼륨을 사용하면 스택 배포와 함께 볼륨이 생성되지만, 이 볼륨은 스택을 제거해도 삭제되지 않는다.

### 비밀값과 컨피그 객체

* 비밀값과 컨피그 객체는 설정값이 든 파일을 클러스터에 업로드하는 방법으로 생성한다. 비밀값과 컨피그 객체는 클러스터 데이터베이스에 저장됐다가 이 비밀값이나 컨피그 객체를 사용하는 컨테이너가 실행될 때 해당 컨테이너로 전달된다. 비밀값과 컨피그 객체는 전형적인 읽기 위주 객체로, 수정이 불가능하다. 스웜 환경에서 애플리케이션 설정 관리는 배포 프로세스와 별개다.

### 네트워크

* 네트워크는 애플리케이션과 별도로 관리된다. 관리자가 명시적으로 네트워크를 생성할 수도 있고 필요할 때마다 스웜이 네트워크를 생성하기도 한다. 모든 스택은 컴포즈 파일에 네트워크가 정의되지 않았더라도 자신이 포함한 서비스를 연결할 네트워크와 함께 배포된다.

### 서비스

* 서비스는 스택이 배포될 때 생성되거나 제거된다. 서비스가 실행 중일 때는 스웜이 서비스를 모니터링하며 서비스 수준이 정상치를 유지하는지 확인한다. 헬스 체크를 통해 이상이 검출된 컨테이너는 새로운 컨테이너로 교체되며, 고장을 일으킨 노드에서 실행 중이던 컨테이너도 마찬가지로 교체된다.
