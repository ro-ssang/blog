# 6장 도커 볼륨을 이용한 퍼시스턴트 스토리지

## 컨테이너의 파일 시스템

* 컨테이너의 파일 시스템은 **이미지 레이어와 기록 가능 레이어로 구성**된 가상 파일 시스템으로 이루어지며, **모든 컨테이너는 독립된 파일 시스템**을 갖는다.

### 이미지 레이어

* 이미지 레이어는 모든 컨테이너가 공유하며, 읽기 전용이다.
* 이미지 레이어의 생애주기는 이미지를 내려받은 순간부터 삭제할 때까지 로컬 컴퓨터의 이미지 레이어에 존재한다.

### 기록 가능 레이어

* 기록 가능 레이어는 각 컨테이너가 따로 갖고 있으며, 읽기 및 쓰기가 가능하다.
* 기록 가능 레이어의 생애주기는 컨테이너를 실행할 때 생성되며 컨테이너를 삭제할 때 함께 삭제된다. 즉, 컨테이어와 같은 생애주기를 갖는다.
* 기록 가능 레이어는 새 파일을 만들 수 있을 뿐만 아니라, 기존 이미지 레이어에 있는 파일을 수정할 수도 있는데, 만약 컨테이너에서 이미지 레이어에 포함된 파일을 수정하려 하면, 먼저 도커가 이 파일을 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 이 파일을 수정한다.



## 도커 볼륨

* 도커 볼륨은 도커에서 스토리지를 다루는 단위이며, 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다.
* 볼륨을 생성해 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉터리가 되며, 나중에 애플리케이션을 업데이트하더라도 새로운 컨테이너에 다시 볼륨을 연결하면 데이터가 그대로 유지된다.

### 도커 볼륨 생성 방법


1. `VOLUME` 인스트럭션을 이용한 도커 볼륨 생성

   * Dockerfile 스크립트에서 `VOLUME` 인스트럭션을 사용하면, Dockerfile 스크립트로 생성한 이미지를 이용하여 컨테이너를 실행하면 자동으로 볼륨을 생성한다.

     ```dockerfile
     # ...
     FROM diamol/dotnet-aspnet
     WORKDIR /app
     ENTRYPOINT ["dotnet", "ToDoList.dll"]

     VOLUME /data
     COPY --from=builder /out/ .
     ```

   * 도커 이미지에서 볼륨을 정의하면 컨테이너를 생성할 때마다 새로운 볼륨을 만드는데, 컨테이너를 실행할 때, `volumes-from` 플래그를 사용하면 컨테이너간 같은 볼륨을 공유하게 할 수 있다.

     ```sh
     docker container run --name todo3 -d --volumes-from todo1 diamol/ch06-todo-list
   
2. `docker create volume` 명령어를 이용한 도커 볼륨 생성

   * `VOLUME` 인스트럭션을 이용하면 볼륨 이름이 무작위로 지정되는데, `docker create volume` 명령어로 직접 볼륨을 생성하면 볼륨을 명시적으로 관리할 수 있다.

     ```sh
     # 데이터를 저장할 볼륨 생성
     docker volume create todo-list
     
     # 볼륨울 연결해 애플리케이션 실행
     docker container run --name todo-v1 -d -p 8011:80 -v todo-list:/data diamol/ch06-todo-list
     ```

> ⚠️ `VOLUME` 인스트럭션과 `--volume` 플래그의 차이점
>
> `VOLUME` 인스트럭션을 사용해 빌드된 이미지로 `docker container run` 명령에서 볼륨을 지정하지 않으면 항상 새로운 볼륨을 함께 생성하는 반면, `--volume` 플래그는 이미지에 볼륨이 정의돼 있더라도 지정된 볼륨을 컨테이너에 마운트한다. 



## 바인드 마운트

* 바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다.
* 또한 바인드 마운트는 컨테이너가 호스트 컴퓨터 파일에 직접 접근할 수 있고 그 반대도 가능하기 때문에, 컨테이너에서 만든 파일을 호스트 컴퓨터에서 수정할 수도 있고, 반대로 호스트에서 만든 파일도 컨테이너에서 수정할 수 있다.

### 바인드 마운트 사용법

```sh
docker container run --mount type=bind,source=$source,target=$target -d -p 8012:80 diamol/ch06-todo-list
```

### 바인드 마운트의 한계점

* 컨테이너에 마운트할 디렉터리가 존재하고 이미지 레이어에 이 디렉터리의 파일이 포함돼 있는 경우

  > 이미지 레이어에 존재하는 디렉터리에 마운트하면 마운트하려는 디렉터리가 이미지 레이어에 존재하는 디렉터리를 완전히 대체한다.
* 호스트 컴퓨터의 파일 하나를 컨테이너에 이미 존재하는 디렉터리로 마운트하는 경우

  > 디렉터리의 파일이 합쳐져 이미지에서 온 파일과 호스트에서 마운트된 파일이 모두 나타난다. 단, 윈도 컨테이너는 이 기능을 제공하지 않아 동작이 달라진다.

* 분산 파일 시스템을 컨테이너에 바인드 마운트하는 경우

  > 대개 분산 파일 시스템의 메커니즘은 로컬 컴퓨터 운영체제의 파일 시스템과 다른 경우가 많다. 따라서 이러한 분산 파일 스토리지를 컨테이너에 마운트하면 일반적인 파일 시스템의 일부처럼 보이기는 하겠지만 지원하지 않는 동작이 있을 수 있다.



## 컨테이너의 파일 시스템은 어떻게 만들어질까?

* 모든 컨테이너는 도커가 다양한 출처로부터 모아 만든 단일 가상 디스크로 구성된 파일 시스템을 갖는데 이 파일 시스템을 **유니언 파일 시스템**이라고 한다.
* 컨테이너는 유니언 파일 시스템을 통해 물리적 위치가 서로 다른 파일과 디렉터리에 마치 단일 디스크를 사용하듯 접근할 수 있다.
* 즉, 컨테이너에서 실행되는 애플리케이션의 입장에서는 단일 디스크만을 볼 수 있지만, 컨테이너나 이미지를 생성해 사용하는 사용자는 여러 출처를 합쳐 이 디스크를 구성할 수 있다.
* 디스크를 구성할 때 여러개의 이미지 레이어, 하나 이상의 볼륨 마운트와 바인드 마운트를 컨테이너에 연결할 수 있으나 기록 가능 레이어는 하나밖에 가질 수 없다.

### 기록 가능 레이어

* 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터의 캐싱 등 단기 저장에 적합하다.
* 각 컨테이너마다 독립적인 기록 가능 레이어를 갖지만, 컨테이너가 삭제되면 여기 저장된 데이터는 유실된다.

### 로컬 바인드 마운트

* 호스트 컴퓨터와 컨테이너 간 데이터를 공유하기 위해 사용한다.
* 개발자의 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달하기 위해 사용하면 로컬 컴퓨터에서 수정한 내용이 이미지 빌드 없이도 즉시 컨테이너로 전달될 수 있다.

### 분산 바인드 마운트

* 네트워크 스토리지와 컨테이너 간에 데이터를 공유하기 위해 사용한다.
* 가용성이 높지만 로컬 디스크와 비교해 지원하지 않는 파일 시스템 기능이 있거나 성능면에서 차이가 있을 수 있다.
* 읽기 전용으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있으며 읽기 쓰기 가능으로 데이터를 저장해 동일 네트워크상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는 데 적합하다.

### 볼륨 마운트

* 컨테이너와 도커 객체인 볼륨 간에 데이터를 공유하기 위해 사용된다.
* 볼륨 마운트를 사용하면 애플리케이션이 볼륨에 데이터를 영구적으로 저장한다.
* 컨테이너를 교체하는 방식으로 애플리케이션을 업데이트해도, 이전 버전 컨테이너의 데이터를 그대로 유지할 수 있다.

### 이미지 레이어

* 이미지 레이어는 컨테이너의 초기 파일 시스템을 구성한다.
* 레이어는 적층 구조를 갖는데, 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우 후속 레이어의 내용이 적용된다.
* 이미지 레이어는 읽기 전용이며 여러 컨테이너가 공유한다.



## 생각해보기

- USER 인스트럭션이 하는 역할?
- p135 하단 2문단이 이해가 안됨
- 하드 링크란?
- 유니언 파일 시스템이란?
